{
  "name": "Introduction processing",
  "tagline": "This respository is a french introduction to the Processing programming language",
  "body": "# Introduction_Processing\r\nThis respository is a french introduction to the Processing programming language\r\n\r\nNotes : \r\n* Le dossier \"bonus\" propose des outils à usage spécifique. Les explications sont disponnibles dans le code sous forme de commentaires.\r\n* Ce document ne se veut pas exhaustif, il présente les fonctions principales dont nous aurons l’utilité dans le cadre de ce cours. Processing étant très bien documenté il est très facile de trouver de nombreux tutoriels en ligne sur les différents aspects du programme. Se référer à la section « Ressources » pour plus d’informations.\r\n* Ce document a pour but de rappeler les informations vues en cours sous une autre forme et d'en apporter de nouvelles, sa lecture doit donc s’accompagner des exemples de code construits pendant le module.\r\n\r\n\r\n\r\n# Contenu\r\n* [Introduction](#Introduction)<br>\r\n* [L'IDE](#ide)<br>\r\n* [Premier Programme](#Premier-Programme)<br>\r\n* [Les variables](#Les-variables)<br>\r\n * [Définition](#définition)<br>\r\n * [Différents types de variables](#types)<br>\r\n * [La portée des variables](#portée)<br>\r\n * [Exemple d’utilisation des variables](#exemples)<br>\r\n * [Variables globales de processing](#globales)<br>\r\n* [L’aléatoire](#L’aléatoire)<br>\r\n * [random()](#random)<br>\r\n * [noise()](#noise)<br>\r\n * [randomSeed() et noiseSeed()](#randomSeed)<br>\r\n* [Les boucles](#Les-boucles)<br>\r\n * [for()](#for)<br>\r\n * [while()](#while)<br>\r\n * [Exemple](#exemple)<br>\r\n* [Couleurs](#Couleurs)<br>\r\n * [Niveaux de gris](#gris)<br>\r\n * [Mode RGB](#rgb)<br>\r\n * [Mode HSB](#hsb)<br>\r\n * [Transparence](#transparence)<br>\r\n* [Primitives de dessin](#Primitives-de-dessin)<br>\r\n * [Les instructions de dessin](#instructions)<br>\r\n * [Les primitives (formes prêtes à l'emploi)](#primitives)<br>\r\n * [Les vertices (formes sur mesure)](#vertices)<br>\r\n* [Transformation de l’espace](#Transformation-de-l’espace)<br>\r\n * [translate()](#translate)<br>\r\n * [rotate()](#rotate)<br>\r\n* [Coder ses propres fonctions](#Coder-ses-propres-fonctions)<br>\r\n* [Interactions Souris et clavier](#Interactions-Souris-et-clavier)<br>\r\n * [Souris](#souris)<br>\r\n  * [Variables globales](#souris-globales)<br>\r\n  * [Fonctions](#souris-fonctions)<br>\r\n  * [map()](#map)<br>\r\n * [Clavier](#clavier)<br>\r\n* [Dessiner du texte et utiliser des polices de caractère](#Dessiner-du-texte-et-utiliser-des-polices-de-caractère)<br>\r\n* [Les Classes Programmation Orientée Objet](#Les-Classes-Programmation-Orientée-Objet)<br>\r\n * [Structure d'une classe](#structure-classe)<br>\r\n * [Construction d’un classe simple](#construction-classe)<br>\r\n  * [Déclaration de variables](#variables-classe)<br>\r\n  * [Constructeur : initialisation](#constructeur-classe)<br>\r\n  * [Méthodes complémentaires : update() et draw()](#méthodes-classe)<br>\r\n * [Utilisation d’un classe simple](#utilisation-classe)<br>\r\n* [Les Tableaux](#Les-Tableaux)<br>\r\n* [Emergence : Un programme interactif complexe](#Emergence)<br>\r\n* [Travailler avec les images](#Travailler-avec-les-images)<br>\r\n * [Charger et afficher une image](#charger-image)<br>\r\n * [Accéder aux pixels](#pixels-image)<br>\r\n * [Explosion de pixels en 3D](#pixels-3d)<br>\r\n* [Les Librairies](#Les-Librairies)<br>\r\n * [Installation d'une librairie](#installation)<br>\r\n * [ControlP5 pour la création de gui](#cp5)<br>\r\n * [OSCP5 pour la communication entre divers programmes](#oscp5)<br>\r\n* [3D et audio réactif avec Pure-Data](#audio-réactif)<br>\r\n* [Trucs et astuces](#Trucs-et-astuces)<br>\r\n* [Ressources](#Ressources)<br>\r\n\r\n<a name=\"Introduction\"/>\r\n#Introduction\r\n\r\nProcessing est un langage de programmation basé sur java et principalement destiné à la création\r\ngraphique. Il est apparut en 2001, crée par deux artistes Ben Fry et Casey Reas, alors étudiants au\r\nMIT. Il reprend une partie des concepts de Design by Numbers l’environnement de programmation\r\ngraphique developpé par John Maeda au sein du Média Lab du même MIT.\r\n\r\nLe langage processing est du Java fortement simplifié par l’accès direct à de nombreuses primitives\r\nde dessin. Il a été crée spécialement dans le but de faciliter l’apprentissage des bases de la\r\nprogrammation objet, via la création graphique permettant ainsi d’obtenir des résultats valorisants\r\ntrès rapidement.\r\n\r\n<p><i>\r\nProcessing seeks to ruin the careers of talented designers by tempting them away from their\r\nusual tools and into the world of programming and computation. Similarly, the project is designed\r\nto turn engineers and computer scientists to less gainful employment as artists and designers.\r\n</i></p>\r\n\r\nAu-delà du fait d’être un formidable outil de dessin et de prototypage rapide en terme de design\r\nd’interaction. Processing est un réel langage de programmation capable de réaliser n’importe quelle\r\nfonction.\r\n\r\nProcessing est un projet Open Source devenu collaboratif de par l’intérêt qu’il a suscité dès sa sortie.\r\nIl est ouvert au développements tiers par l’intégration d’un système de librairie ainsi qu’une\r\ndocumentation aidant au développement de librairies externes. Il existe aussi un système\r\nde « modes » permettant d’ajouter des fonction à l’IDE (Itegrated Developpement Environment) de\r\nprocessing comme le développement pour android (smartphones et tablettes), ou en javascript\r\n(web).\r\n\r\nProcessing existe aussi bien sous Linux, Windows que Mac OS. Le projet étant à but pédagogique et\r\nporté par une communauté très active il est excessivement bien documenté.\r\n\r\n<a name=\"ide\"/>\r\n#L'IDE\r\nIDE signifie Inegrated Developpemet Environment, c'est l'outil avec lequel on va travailler, c'est la fenêtre qu'ouvre notre système d'exploitation lorsque l'on lance processing. Cela ressemble à un éditeur de texte, mais nous avons des boutons pour compiler nos programmes et une seconde fenêtre de rendu qui s'ouvre à la compilation.\r\n\r\n![L'IDE de Processing](assets/001_IDE.png)\r\n\r\n* La zone 1 correspond à la barre d’action, en haut à gauche se situe différents boutons : le premier « run » permet de lancer son programme, le second « stop » permet de le stopper. En dessous se trouve un système d’onglet, cela permet de mieux organiser son code quand les programmes deviennent plus complexes. Tout à droite se trouve un menu déroulant permettant de passer d’un mode à un autre (c’est-à-dire d’un developpement android à un developpement java classique par exemple).\r\n\r\n* La zone 2 est un éditeur de texte classique permettant d’écrire son programme. Les mots clés du langage processing y apparaitront en surbrillance. Il est important de noter qu’à tout moment il est possible de consulter la documentation en ligne en effectuant un clic droit sur un mot clé et en sélectionnant « find in reference ».\r\n\r\n* La zone 3 est la console qui renvoi les erreurs rencontrées par l’ordinateur lorsqu’il tente d’exécuter un programme. C’est aussi une zone d’information dans laquelle on peut choisir d’afficher des messages (à l’aide de la fonction println()).\r\n\r\n* La zone 4 est la fenêtre d’exécution de notre programme. \r\n\r\nProcessing fonctionne par défaut avec l’utilisation d’un « sketchbook ». C’est un dossier sur votre disque dur dans lequel seront stockés vos programmes et toutes les librairies, ainsi que les diférents modes que vous avez installé. Il est possible de modifier l’emplacement de ce dossier en allant dans : <i> File -> Preferences </i>\r\n\r\n<a name=\"Premier-Programme\"/>\r\n#Premier Programme\r\n\r\nA tout moment il est possible d’insérer un commentaire dans son programme en utilisant ces deux caractères en début de ligne  « // ». On peut aussi créer des commentaires sur plusieurs lignes en utilisant ces caractères :« / »  suivi de « * » pour signaler le début d’un commentaire, et de « * » suivi de « / » pour signaler la fin de ce même commentaire.\r\n\r\n```java\r\n// voici mon premier programme\r\nvoid setup() {\r\n  size(200, 200) ; // permet de spécifier la taille de la fenêtre.\r\n  background(0) ; // utilisons un fond noir.\r\n}\r\nvoid draw() {\r\n  background(0) ; // dessinons un fond noir.\r\n  stroke(180) ; // on choisit de  dessiner un contour gris.\r\n  strokeWeight(2) ; // ce contour aura un épaisseur de 2 pixels.\r\n  fill(255) ; // le remplissage de notre dessin sera blanc.\r\n  /* on dessine une ellipse située à 100 pixels du bord gauche, à 100 pixels du bord haut, d’une largeur de 50 pixels et d’une hauteur de 50 pixels … un cercle donc ! */\r\n  ellipse(100, 100, 50, 50) ;\r\n}\r\n\r\n```\r\n![exemples_pdf/Sketch_1_01.pde](assets/002_PremierProgramme.png)\r\n\r\nCe programme se compose de deux parties principales, appelées aussi « fonctions » qui se démarquent par l’utilisation de mots clés **« void »** ainsi que la paire d’accolade **{** **}** qui délimite les instructions exécutées lors de l’appel de la fonction.\r\n\r\n* Les lignes 02 à 05 : présentent la fonction **setup()**. Cette fonction est appelée une seule fois au démarrage du programme, c’est un initialisation.\r\n* Les lignes 06 à 12 : présentent la fonction **draw()**, qui est le cœur du programme. La suite d’instruction enfermée entre les accolades est exécutée en boucle, le plus rapidement possible.\r\n\r\nIl existe des fonction spécifique au langage processing appelée primitives, on peut les appeler simplement en utilisant leur syntaxe spécifique. Chaque fonction indiquée en surbrillance possède une documentation en ligne, il est fortement conseillé de s’y référer pour savoir comment les utiliser.\r\n\r\nA noter que par défaut nous utilisons un systèmes de coordonnées cartésiennes centré en haut à gauche de la fenêtre de dessin. Dans notre programme, le coin en haut à gauche a donc les coordonnées(0,0), le coin en bas à droite a donc les coordonnées (199,199) \r\n\r\n<a name=\"Les-variables\"/>\r\n#Les variables\r\n\r\n<a name=\"définition\"/>\r\n##Définition\r\nLes variables correspondent à un espace utilisé dans la mémoire de l’ordinateur pour stocker une information de manière temporaire. Les variables peuvent être de différents types en fonction des données qu’elles doivent stocker.\r\n\r\n<a name=\"types\"/>\r\n##Différents types de variables\r\n**int** : permet de stocker des nombres entiers.\r\n**float** : permet de stocker des nombres flottants soit des nombres à virgules.\r\n**string** : permet de stocker des chaines de caractères, c’est-à-dire du texte.\r\n**color** : permet de stocker une couleur.\r\n\r\nSi on écrit :\r\n\r\n```java\r\n\r\nint a;\r\na = 5;\r\nint b ;\r\nb =3;\r\nint result = a + b;\r\nString operation = a +\"+\"+ b +\"=\";\r\nprintln(operation);\r\nprintln(result);\r\n\r\n```\r\n\r\nOn crée une variable entière dont le nom est a, et on lui attribue la valeur 5. On crée une seconde variable entière dont le nom est b et on lui attribue la valeur 3. On crée ensuite un entier pour stocker le résultat que l’on obtient en additionnant les deux variables.\r\n\r\nOn crée ensuite une variable de type chaine de caractère pour inscrire l’opération effectuée puis son résultat dans la console. Une chaine de caractère doit être comprise entre deux \" \" pour être reconnue comme telle.  Ici on compose une chaine de caractère complexe en utilisant le symbole « + », les différentes chaines de caractères (ou caractères simples) qui la compose sont accolées.\r\n\r\nIl est important de noter que si jamais notre variable appelée « result » avait été de type String, la ligne :\r\n\r\n```java\r\nString result = a+b ;\r\n```\r\n\r\naurait renvoyé un tout autre résultat puisque les variables aurait été interprétée comme des String on aurait alors obtenu le juxtaposition des deux caractère soit « 53 ».\r\n\r\nCertain type sont compatibles avec d’autres : on peut par exemple stocker un entier dans un flottant et des entiers ou des flottants dans des String. Cependant l’utilisation d’un flottant avec un type entier reverra nécessairement une erreur dans la console.\r\n\r\nIl est aussi possible de stocker des données plus complexes comme des tableaux. Les tableaux servent à stocker des ensembles de données d’un type précis, on peut même y stocker des instances de classes… (nous verrons ceci dans la section dédiée aux classes).\r\n\r\n<a name=\"portée\"/>\r\n##La portée des variables\r\n\r\nUn point essentiel réside dans la portée de ces variables (en anglais on parle de « scope »). D’une façon simplifiée : une variable sera accessible uniquement dans la fonction ou portion de code dans laquelle elle aura été définie. Une portion de code correspond à l’espace entre deux accolades « { } ».\r\n\r\nCela signifie qui si je définie une variable dans le setup() de mon programme celle-ne sera accessible uniquement dans le setup().\r\n\r\nIl est possible de définir des variables à l’extérieur des fonctions setup() et draw() : par exemple en tout début de programme, ces variables seront alors accessibles partout dans notre programme.\r\n\r\n<a name=\"exemples\"/>\r\n##Exemple d’utilisation des variables\r\n\r\nHabituellement on a tendance à créer les variables tout en haut de notre programme, on les initialise ensuite dans le setup() , puis on les utilise dans le draw().\r\n\r\n```java\r\n  // voici mon premier programme utilisant des variables\r\n  color background_color ;\r\n  int size ;\r\n  float xpos,ypos ;\r\n  \r\n  void setup(){\r\n  size(200,200) ;\r\n  background_color = color(0) ;\r\n  size = 50 ;\r\n  xpos = random(100) ;\r\n  ypos = random(100) ;\r\n  background(background_color ) ; // utilisons un fond noir.\r\n  }\r\n  \r\n  void draw(){\r\n  background(background_color ) ; \r\n  stroke(180) ; \r\n  strokeWeight(2) ; \r\n  fill(255) ;\r\n/* on dessine notre ellipse en utilisant nos variables*/\r\n  ellipse(xpos,ypos,size,size) ; \r\n  }\r\n```\r\n![exemples_pdf/Sketch_1_02.pde](assets/003_Utilisation_variables.png)\r\n\r\n<a name=\"globales\"/>\r\n##Variables globales de processing\r\n\r\nIl existe dans processing des variables globales, qui sont donc accessibles partout dans processing, ces variables sont définies par défaut et gérée par processing lui-même, il faut mieux éviter d’utiliser leur nom pour définir ses propres variables.\r\n\r\nC’est le cas entre autres de :\r\n\r\n**width** : (float) qui est associée par défaut à largeur de la fenêtre de dessin.\r\n**height** : (float) qui est associée par défaut à la hauteur de la fenêtre de dessin.\r\n\r\n<a name=\"L'aléatoire\"/>\r\n#L'aléatoire\r\n\r\nEn informatique et en design génératif , l’aléatoire est très souvent utilisé pour obtenir des résultats présentant des variantes contraintes, c’est-à-dire pour obtenir plusieurs variations d’un même algorithme.\r\n\r\nIl existe deux principales façon d’obtenir des nombres aléatoires ou plutôt pseudo-aléatoire, car il n’existe pas en informatique de méthode permettant d’obtenir un résultat réellement et statistiquement complètement aléatoire.\r\n\r\n<a name=\"random\"/>\r\n##random()\r\n\r\nLa fonction random() renvoit donc des résultats aléatoires en fonction d’un argument qui sera spécifié entre les parenthèses. Ce nombre aléatoire sera de type float.\r\nPar exemple :\r\n```java\r\nfloat nb_aleatoire = random(100) ;\r\nprintln(nb_aleatoire) ;\r\n ```\r\nnous obtiendrons avec ce code un nombre aléatoire compris entre 0 et 100.\r\n\r\nIl est aussi possible de spécifier un borne supérieur, ainsi qu’un borne inférieure, ainsi :\r\n```java\r\nfloat nb_aleatoire = random(20,50) ;\r\nprintln(nb_aleatoire) ;\r\n```\r\nrenverra une valeur aléatoire comprise entre 20 et 50 ;\r\n\r\n```java\r\n/* voici mon premier programme utilisant des variables et de l’aléatoire */\r\nint size ;\r\nfloat xpos, ypos ;\r\n\r\nvoid setup() {\r\n  size(200, 200) ;\r\n  size = 25 ;\r\n  xpos = random(0, width) ;\r\n  ypos = random(0, height) ;\r\n  background(0 ) ; // utilisons un fond noir.\r\n}\r\n\r\nvoid draw() {\r\n  background(0) ; \r\n  stroke(180) ; \r\n  strokeWeight(2) ; \r\n  fill(255) ;\r\n  // à chaque image calculée on définit une nouvelle position\r\n  xpos = random(0, width) ;\r\n  ypos = random(0, height) ;\r\n  /* on dessine notre ellipse en utilisant nos variables*/\r\n  ellipse(xpos, ypos, size, size) ;\r\n}\r\n```\r\n\r\nCe programme va dessiner, à chaque image, un cercle positionné aléatoirement dans la fenêtre de dessin.\r\n\r\n![exemples_pdf/Sketch_1_03.pde](assets/004_Aléatoire.png)\r\n\r\n<a name=\"noise\"/>\r\n##noise()\r\n\r\nLa fonction noise() est un peu particulière puisque elle permet de générer des suites de nombres très proches les uns des autres. Cela permet notament de créer des mouvement et des contours qui paraissent plus naturels.\r\n\r\nSon usage est un peu plus compliqué car il faut lui fournir un argument  « évolutif », celle-ci renvoi des valeurs comprises entre 0 et 1. Il faut donc souvent adapter le résultat obtenu en fonction de nos besoins.\r\n\r\n```java\r\nfloat noiseF; // facteur évolutif de notre fonction noise\r\nfloat xpos, ypos; // coordonnées de notre forme\r\n\r\nvoid setup() {\r\n  size(200, 200);\r\n  background(0);\r\n  noStroke();\r\n  fill(255);\r\n  // on initialise notre facteur à une valeur aléatoire\r\n  noiseF = random(500) ;\r\n  // on place notre forme au centre de la fenetre.\r\n  xpos = width/2;\r\n  ypos = height/2;\r\n}\r\n\r\nvoid draw() {\r\n  background(0);\r\n  /* on ajoute à notre position une valeur comprise entre      -1 et 1, résultante de notre fonction noise. */\r\n  xpos += noise(noiseF, 10, 20)*2-1;\r\n  ypos += noise(noiseF, 85, 140)*2 -1;\r\n  ellipse(xpos, ypos, 5, 5);  \r\n  // on incrémente notre facteur noise d’une petite valeur\r\n  noiseF += 0.005;\r\n}\r\n```\r\n![exemples_pdf/Sketch_1_04.pde](assets/005_Noise.png)\r\n\r\nCe programme dessine un cercle qui va se déplacer aléatoirement dans l’espace de dessin. Il est d’ailleurs fort probable qu’il en sorte, mais nous y reviendrons plus tard.\r\n\r\n<a name=\"randomSeed\"/>\r\n##randomSeed() et noiseSeed()\r\n\r\nCes deux fonctions permettent de pouvoir retrouver un résultat qui a été obtenu avec des nombres aléatoires. Comme mentionné ci-dessus, les ordinateurs ne permettent pas d’avoir des générateurs de nombres complétement aléatoires, dans certain cas cela peut-être un avantage, notament quand il s’agit de pouvoir régénérer exactement la même image avec un algorithme qui utilise pourtant des nombres aléatoires.\r\n\r\nCes fonctions s’utilisent de la même façon ( exemples_pdf/Sketch_1_05.pde ) :\r\n\r\n```java\r\nint seed ;\r\nseed = 123;\r\n\r\nrandomSeed(seed);\r\nfloat a = random(500);\r\nprintln(\"seed\" + seed +\" : \" + a); \r\n\r\nseed = 52;\r\nrandomSeed(seed);\r\na = random(500);\r\nprintln(\"seed\" + seed +\" : \" + a); \r\n\r\nseed = 123;\r\nrandomSeed(seed);\r\na = random(500);\r\nprintln(\"seed\" + seed +\" : \" + a); \r\n```\r\n\r\n<a name=\"Les-boucles\"/>\r\n#Les Boucles\r\n\r\nC’est un des point primordiaux de la programmation objet, le boucles permette de répéter une action ou une suite d’instruction un nombre limité de fois. Il existe les boucles dites « for », et les boucles dites « while ». \r\n\r\nDans le cadre de ce document nous n’allons traiter que les boucles «for », les boucles « while » étant relativement rarement usitées.\r\n\r\n<a name=\"for\"/>\r\n##for()\r\nvoici un exemple de boucle « for » :\r\n\r\n```java\r\nfor (int i  = 0 ; i < 10 ; i=i+1){\r\n\tnoStroke() ;\r\n\tfill(255) ;\r\n\tellipse (10+i*10, 10+i*10, 5,5) ;\r\n}\r\n```\r\n\r\nUn boucle for se compose, de deux parties :\r\n\r\n* Un bloc d’instructions à exécuter,  situé entre les deux accolades.\r\n\r\n* Entre les parenthèses  ce sont les conditions d’exécution de la boucle qui sont séparées par des points virgules. \r\n * D’abord, on définit un nombre entier appelé « i » que l’on initialise à  0, \r\n * ensuite on précise que l’on exécutera le bloc d’instruction uniquement si  « i » reste strictement inférieur à 10, \r\n * puis on incrémente « i » de 1 en lui ajoutant la valeur 1.\r\n\r\nLe code présenté ci-dessus permet donc de dessiner 10 cercles blancs de 5 pixels de diamètre, le premier étant situé en haut à gauche aux coordonnées (10,10), le dernier au coordonnées (100,100).(100 = 10 + 9*10).\r\n\r\nComme nous le verrons ces boucles sont très utilisées en programmation objet car elles permettent d’itérer une série d’instructions sur les éléments d’un tableau.\r\n\r\n<a name=\"while\"/>\r\n##While()\r\n\r\nLa boucle while() est moins usitée en programmation objet, mais très commune en électronique, elle permet de réaliser un bloc d’instruction tant qu’une condition est vérifiée.\r\n\r\n```java\r\nint i =0 ;\r\nwhile (i < width){\t\r\nnoStroke();\r\nfill(255);\r\n      ellipse(i,height/2,5,5);\r\ni+=5;\r\n}\r\n```\r\nIci, nous avons un variable initialisée à zéro, tant que cette variable est inférieure à la largeur de notre fenêtre de dessin, nous dessinons une ellipse blanche, de 5 pixels de diamètre placée en abscisses à la valeur de « i » et en ordonnées au milieu de notre fenêtre de dessin.\r\n\r\n<a name=\"exemple\"/>\r\n##Exemple\r\n\r\n```java\r\n/* voici mon premier programme utilisant des variables et de l’aléatoire et une boucle for*/\r\nint size ;\r\nfloat xpos,ypos ;\r\n  \r\nvoid setup(){\r\n  size(200,200) ;\r\n  size = 25 ;\r\n  xpos = random(0,width) ;\r\n  ypos = random(0,height) ;\r\n  background(0 ) ; // utilisons un fond noir.\r\n}\r\n \r\nvoid draw(){\r\n  background(0) ; \r\n  stroke(180) ; \r\n  strokeWeight(2) ; \r\n  fill(255) ;\r\n  for (int i = 0 ; i <10 ; i++){\r\n  // à chaque image calculée on définit une nouvelle position\r\n  xpos = random(0,width) ;\r\n  ypos = random(0,height) ;\r\n  ellipse(xpos,ypos,size,size) ; \r\n  }\r\n}\r\n``` \r\n\r\n![exemples_pdf/Sketch_1_06.pde](assets/006_boucles.png)\r\n\r\n\r\n<a name=\"couleur\"/>\r\n#Couleur\r\n\r\n<a name=\"gris\"/>\r\n##Niveaux de gris\r\n\r\nDans processing il existe trois mode principaux de couleurs. Le premier mode est celui que nous avons déjà utilisé dans les exemples précédents : le mode grayscale ou niveau de gris. Dans ce mode il s’agit de signifier un nombre entre 0 et 255 ; 0 étant le noir et 255 le blanc.\r\n\r\n```java\r\nstroke(0) ;\r\nfill(180) ;\r\nellipse(width/2,height/2,50,50) ;\r\n```\r\nLe code va donc dessiner un cercle gris souris avec un contour noir.\r\n\r\n<a name=\"rgb\"/>\r\n##Le mode RGB\r\n\r\nLe mode de couleur par défaut de processing est le mode RGB (« Red Green Blue »), pour créer des couleurs il s’agit alors de spécifier les niveau de rouge, vert et de bleu que l’on souhaite entre 0 et 255 ;\r\n\r\n```java\r\nnoStroke() ;\r\nfill(255,0,0) ; // Rouge\r\nellipse(width/5,height/2,10,10) ;\r\nfill(0,255,0);// Vert\r\nellipse(width*2/5,height/2,10,10);\r\nfill(0,0,255);// Bleu\r\nellipse(width*3/5,height/2,10,10);\r\nfill(255,100,100);// Rose\r\nellipse(width*4/5,height/2,10,10);\r\n```\r\n\r\n<a name=\"hsb\"/>\r\n##Le mode HSB\r\n\r\nLe mode HSB correspond à la specification de niveau de Hue (teinte), Saturation (contraste), Brightness (luminosité). Lorsque l’on définie le mode HSB on spécifie généralement l’étendue de la plage que doivent occuper ces valeurs.\r\n\r\n```java\r\ncolorMode(HSB,360,100,100) ; \r\n```\r\n\r\nCette ligne précise que l’on va spécifier les valeurs de teinte entre 0 et 360, les autres valeurs seron spécifiées entre 0 et 100.\r\nCe mode rend très facile la création de dégradés.\r\n\r\n```java\r\nsize(360,100) ;\r\ncolorMode(HSB,360,100,100) ;\r\nfor (int i =0 ; i < width ; i++){\r\n   stroke(i,100,100);\r\n   line(i,0,i,height);\r\n}\r\n```\r\n\r\n<a name=\"transparence\"/>\r\n##La transparence\r\n\r\nIl suffit d’ajouter un paramètre final à nos couleurs quelque soit le mode choisit. Ce dernier paramètre réglera le niveau de transparence à spécifier entre 0 et 255 ; 0 étant complétement transparent (soit invisible) et 255 étant entièrement opaque.\r\n\r\nDans la création graphique la superposition de plusieurs couches transparentes donne des effets de textures souvent intéressants. L’utilisation de la transparence dans certain cas facilite l’émergence de motifs complexes.\r\n\r\n```java\r\n/* voici mon premier programme utilisant des variables et de l’aléatoire et une boucle for et de couleurs !*/\r\nint size ;\r\nfloat xpos, ypos ;\r\n\r\nvoid setup() {\r\n  size(200, 200) ;\r\n  size = 25 ;\r\n  xpos = random(0, width) ;\r\n  ypos = random(0, height) ;\r\n  colorMode(HSB, 360, 100, 100) ;\r\n  background(0 ) ;\r\n}\r\n\r\nvoid draw() {\r\n  // blur « maison »\r\n  fill(0, 20) ;\r\n  rect(0, 0, width, height) ;\r\n  noStroke() ; \r\n  for (int i = 0 ; i <10 ; i++) {\r\n    xpos = random(0, width) ;\r\n    ypos = random(0, height) ;\r\n    fill(random(360), 100, 100) ;\r\n    ellipse(xpos, ypos, size, size) ;\r\n  }\r\n}\r\n```\r\n\r\n![exemples_pdf/Sketch_1_07.pde](assets/007_couleurs.png)\r\n\r\n\r\n<a name=\"Primitives-de-dessin\"/>\r\n#Primitives de dessin\r\n\r\nA partir de maintenant nous allons abandoner notre programme fil-rouge, qui nous a déjà appris beaucoup de choses, pour nous pencher vers d’autres rendus graphiques plus riches.\r\n\r\n<a name=\"instructions\"/>\r\n##Les instructions de dessin\r\n\r\nNous avons déjà vu la majeure partie des instructions de dessins dans les programmes précèdents, mais opérons tout de même à un petit rappel : \r\n\r\n * stroke() ; (color)  permet de définir la couleur du trait de dessin.\t\r\n * strokeWeigth() ; (float) permet de définir l’épaisseur de ce trait.\r\n * noStroke() ; autorise à ne pas dessiner de contour.\r\n * fill() ; (color) permet de définir la couleur de remplissage d’une forme.\r\n * noFill() ; autorise à ne pas coloriser une forme.\r\n\r\nConcenant les instruction de lignes, il existe aussi les fonction strokeCap() ;(String) et strokeJoint() ; (String) dont je vous invite à consulter la documentation en ligne.\r\n\r\nUne autre instruction est importante , il s’agit de smooth() ; qui permet de modifier les paramètres de l’anti-aliasing de processing. On peut lui attribuer les valeurs de 2, 4 ou 8. Cela permet d’avoir des lignes fines plus précises à haute résolution.\r\n\r\n<a name=\"primitives\"/>\r\n##Les primitves (formes)\r\n\r\nNous avons pour l’instant principalement utilisé des ellipses pour nos code. Mais processing regorge d’une bonne quantité de primtives pour dessiner différentes formes géométriques.\r\n\r\n* ellipse(x-coord, y-coord, width,heigth) ; permet donc de dessiner une ellipse\r\n* line(x1-coord, y1-coord, x2-coord, y2-coord) ; permet de dessiner une ligne entre les points (x1,y1) et (x2,y2) ;\r\n* rect(x-coord,y-coord,width,height) ; permet de dessiner un rectangle, on peut lui adjoindre jusqu’à quatre autres paramètres pour spécifier l’arrondi de chaque angle.\r\n* quad(x1, y1, x2, y2, x3, y3, x4, y4) ; permet de dessiner un quadrilatère.\r\n* triangle(x1, y1, x2, y2, x3, y3) ; permet de spécifier un triangle.\r\n\r\nIl existe souvent différent modes pour dessiner ces formes, je vous conseille donc de regarder les documentation de rectMode() (String) et ellipseMode() (String) par exemple. On peut par exemple choisir de dessiner à partir d’un coin (CORNER - par défaut lorsque l’on dessine un rectangle), ou à partir du centre de nôtre forme (CENTER – par défaut pour l’ellipse).\r\n\r\n<a name=\"vertices\"/>\r\n##Les vertices (formes sur mesure)\r\n\r\nSi cela ne vous suffisait pas il existe d’autres possibilités pour créer des formes. Les fonctions beginShape(), endShape() et vertex() vont nous y aider.\r\n\r\nUn vertex n’est en fait ni plus ni moins qu’un couple de coordonnées, conjugé à beginShape() et enShape(), il permet de créer des ensembles de points à relier entre eux qui peuvent alors créer des formes complexes. Nous allons nous intéresser à la façon dont il est possible de dessiner un cercle à l’aide de ces fonctions.\r\n\r\nPour rappel, voici un cercle trigonométrique : \r\n\r\nhttp://www.openprocessing.org/sketch/151087\r\n\r\nAlors que les coordonnées cartésiennes utilisent l’abscisse et l’ordonnée d’un point pour le placer dans le plan, les coordonnées polaires utilisent le rayon et l’angle pour définir un point de l’espace. En terme de code informatique il est donc assez facilement imaginable de tracer un cercle à l’aide d’un boucle « for » permettant de parcourir les 360° (ou 2*PI pour ceux qui préfèrent les radians), cependant il nous faut un moyen de passer des coordonnées polaires aux coordonnées cartésiennes (processing et la fonction vertex() demandent en effet un couple de coordonées).\r\n\r\nLe cercle trigo nous permet de nous souvenir simplement de ces formules : le point noir sur le cercle à pour coordonées (x,y) dans un repère cartésien et (r,theta) en coordonnées polaires. \r\n\r\nDans le programme interactif ci dessus, la projection bleue sur l’axe des abscisses nous donne la coordonnée x et correspond à un facteur près au cosinus de l’angle. La projection fuchsia sur l’axe des ordonnées nous fournit la coordonnée y qui est aussi proportionnelle à l’angle, mais cette fois au sinus :\r\n\r\n```java\r\nX = rayon * cos (angle)\r\nY = rayon* sin(angle)\r\n```\r\n\r\nbeginShape() va vous permettre de signaler à Processing que vous allez commencer à dessiner une forme, il attendra donc un instruction de fin de dessin qui sera endShape() et aussi une liste de vertex() entre les deux pour définir les différents points à relier entre eux.\r\n\r\n```java\r\nfloat xpos, ypos ;\r\nint radius; // le rayon de notre cercle\r\nfloat step; // l’incrément de l’angle qui va parcourir une rotation de 360°\r\n\r\nvoid setup() {\r\n  size(200, 200);\r\n  background(0);\r\n  xpos = width/2;\r\n  ypos = height/2;\r\n  radius = 75;\r\n  step = PI/12;\r\n}\r\n\r\nvoid draw() {\r\n  background(0);\r\n  noFill();\r\n  stroke(255);\r\n\r\n  beginShape();// on démarre notre forme\r\n  for ( float angle = 0 ; angle <TWO_PI ; angle += step) {\r\n    // on applique la formule vue précédement\r\n    float ex = xpos + radius *cos(angle);\r\n    float wy = ypos + radius *sin(angle);\r\n    // on ajoute un vertex\r\n    vertex(ex, wy);\r\n  }\r\n  endShape(CLOSE);// on arête notre forme et on la ferme\r\n}\r\n```\r\n![exemples_pdf/Sketch_1_08.pde](assets/008_vertices.png)\r\n\r\nIl est important de noter que ces objets sont très puissant et peuvent être manipulés avec différentes options pour obtenir des résultats divers.\r\n\r\nPar exemple : beginShape(), peut prendre un argument  qui affectera la façon dont la forme sera dessinée. beginsShape(POINTS) dessinera des points, beginShape(LINES) dessinera des lignes,  beginShape(TRIANGLES) constituera des triangles etc.\r\n\r\nPour plus d’informations, il peut-êre utile de se référer à le documentation de Processing concernant beginShape().  Il peut-être intéressant aussi de regarder les fonction beginContour() et endContour().\r\n\r\nConcernant les vertices, il existe aussi plusieurs type de fonctions permettant de les utiliser : curveVertex(), bezierVertex(), quadraticVertex() sont d’autres façons de définir des vertices demandant plus ou moins d’arguments et donc plus ou moins simples à mettre en œuvre.\r\n\r\nEnfin pour ceux qui persiste dans l’utilisation de processing, il est intéressant de regarder le foncionnement de l’objet PShape, qui permet de créer des formes complexes,  de les stocker puis de les manipuler plus facilement.\r\n\r\n<a name=\"Transformation-de-l’espace\"/>\r\n#Les Transformations de l’espace\r\n\r\nC’est un des points primordiaux de processing, il faut savoir se repérer dans un espace 2D et savoir utiliser différents systèmes de coordonnées, pour pouvoir se faciliter la vie.\r\n\r\nIl existe deux types de transformation de l’espace :\r\n\r\n* translate() ;\r\n* rotate() ;\r\n\r\n<a name=\"translate\"/>\r\n##translate()\r\n\r\nCette fonction permet d’opérer une translation, ce qu’il est primordial de comprendre c’est que l’on n’opère pas cette translation sur les formes que l’on dessine, mais plutôt sur notre espace de dessin. C’est comme si l’on gardait notre crayon au même endroit et que l’on déplaçait la feuille.\r\n\r\nPar exemple :\r\n\r\n```java\r\nellipse(width/2,height/2,25,25) ;\r\ntranslate(50,0) ;\r\nellipse(width/2,height/2,25,25) ;\r\n```\r\n\r\ndessinera deux cercles côte à côte séparé dont les centre seront séparés de 50 px. Ce programme est équivalent à : (c’est une question de style)\r\n\r\n```java\r\ntranslate(width/2,height/2) ;\r\nellipse(0,0,25,25) ;\r\ntranslate(50,0) ;\r\nellipse(0,0,25,25) ;\r\n```\r\nremarquez bien que les translations s’enchaînent, il est possible cependant de replacer la feuille à sa position par défaut en utilisant pushMatrix() et popMatrix(). Bien que cela puisse paraître compliqué il suffit de comprendre que si l’on dessine avec translate() il est parfois plus simple d’encadre chaque forme que l’on dessine de ces deux fonctions comme dans l’exemple ci-dessous :\r\n\r\n```java\r\npushMatrix() ;\r\ntranslate(width/2,height/2) ;\r\nellipse(0,0,25,25) ;\r\npopMatrix() ;\r\npushMatrix() ;\r\ntranslate(width/2+50,height/2) ;\r\nellipse(0,0,25,25) ;\r\npopMatrix() ;\r\n```java\r\n\r\ntranslate en réalité déplace notre repère de dessin, par défaut le centre de notre repère (le point de coordonnées (0,0) ) est situé en haut à gauchede notre fenêtre. En utilisant translate(xpos,ypos) ; nous déplaçons ce centre au point de coordonnées (xpos,ypos).\r\nRé-écrivons notre programme fil-rouge avec des tranlate().\r\n\r\n```java\r\n/* voici mon premier programme utilisant des variables et de l’aléatoire et une boucle for et de couleurs ! et des translate(), pushMatrix(), popMatrix()*/\r\nint size ;\r\nfloat xpos,ypos ;\r\n\r\nvoid setup(){\r\n\tsize(200,200) ;\r\n\tsize = 25 ;\r\n\txpos = random(0,width) ;\r\n\typos = random(0,height) ;\r\n\tcolorMode(HSB,360,100,100) ;\r\n\tbackground(0 ) ; \r\n}\r\n\r\nvoid draw(){\r\n\t// blur « maison »\r\n\tfill(0,20) ;\r\n\trect(0,0,width,height) ;\r\n\tnoStroke() ; \r\n\tfor (int i = 0 ; i <10 ; i++){\r\n\txpos = random(0,width) ;\r\n\typos = random(0,height) ;\r\n\tfill(random(360),100,100) ;\r\n\tpushMatrix() ; // on replace la feuille à chaque image\r\n\ttranslate(xpos,ypos) ;// on se déplace\r\n\tellipse(0,0,size,size) ; // on dessine\r\n\tpopMatrix() ; // objet parent de pushMatrix\r\n\t}\r\n}\r\n```\r\n\r\npopMatrix() permet en fait de replace la feuille pour dessiner éventuellement d’autres choses après. Ces deux objets doivent impérativement être utilisés conjointement, l’un sans l’autre renverra une erreur…\r\n\r\n<a name=\"rotate\"/>\r\n##rotate()\r\n\r\nrotate() fonctionne de la même façon que translate(), il faut lui fournir un angle en radians, une fonction radians(angle)  permet de convertir un angle spécifié en degrés en une mesure radian facilement.\r\n\r\nIl existe des variante de rotate que sont rotateX(), rotateY(), rotateZ() sur lesquelles nous ne épancheront pas.\r\n\r\nEn utilisant rotate(), il est nécessaire encore une fois de bien pense au système de coordonnées. Si par exemple je dessine un cercle au mileu tout en haut de ma zone de dessin :\r\n\r\n```java\r\nellipse(width/2,0,50,50) ;\r\n```\r\n\r\nje peux faire en sorte que ce cercle se retrouve au centre en opérant un rotation de 45° ou PI/4 radians :\r\n\r\n```java\r\nrotate(radians(45)) ;\r\nellipse(width/2,0,50,50) ;\r\n```\r\nCela commence intéressant lorsque l’on combine translate() et rotate() ensemble, je peux par exemple très facilement faire tourner un carré sur lui-même. En utilisant le mode CENTER (à la fin de ce paragraphe [ici](#primitives)).\r\n\r\n```java\r\nfloat angle ;\r\nvoid setup() {\r\n  size(200,200);\r\n  angle = 0 ;\r\n  rectMode(CENTER) ;// rappelez vous les modes !\r\n}\r\nvoid draw() {\r\n  background(0) ;\r\n  stroke(255) ;\r\n  pushMatrix();// on s’assure d’avoir un repère bien à nous\r\n  translate(width/2, height/2) ;// on déplace notre repère\r\n  rotate(angle);// on le fait tourner\r\n  rect(0, 0, 25, 25);// on dessine un rectangle\r\n  popMatrix();\r\n  angle += PI/24;// on incrémente l’angle\r\n}\r\n```\r\n\r\n![exemples_pdf/Sketch_1_09.pde](assets/009_translate_rotate.png)\r\n\r\nSi vous intervertissez rotate() et translate() l’effet ne sera plus du tout le même, idem si l’on oublie d’utiliser pushMatrix() et popMatrix().\r\n\r\n\r\n<a name=\"Coder-ses-propres-fonctions\"/>\r\n#Coder ses propres fonctions\r\n\r\nA partir de ces transformations simples nous allons créer une texture mouvante en quelques lignes de code. Le principe est simple  nous allons utiliser le principe du carré tournant autour de son point supérieur gauche, mais nous allons créer une grille de carrés sur toute la surface de l’écran. \r\n\r\nPour simplifier le code nous allons écrire une fonction.  Cette fonction aura pour objectif de dessiner un carré situé à des coordonnées spécifiques avec un angle de rotation propre. Cette fonction étant une fonction de dessin, elle sera de type « void », et elle acceptera les 3 paramètres sus-cités , on la déclarera de cette façon :\r\n\r\n```java\r\nvoid draw_rect(float xpos, float ypos, float rotation) {\r\n\t// suite d’instructions à écrire\r\n}\r\n```\r\n\r\nPour utiliser cette fonction il suffit alors de l’  « appeler » :\r\n\r\n```java\r\ndraw_rect(50,50,PI/2) ;\r\n```\r\nOn dessinera ainsi un rectangle au point de coordonnées (50,50), tourné d’un angle  de PI/2 radians, si le code écrit à l’intérieur de notre fonction est le bon. Heureusement nous avons appris à précédemment à faire exactement cela :\r\n```java\r\nvoid draw_rect(float xpos, float ypos, float rotation) {\r\n\tpushMatrix(); \r\n\tfill(100,100,255,2);\r\n\tstroke(255,100,100,5);\r\n\tstrokeWeight(2);\r\n\ttranslate(xpos, ypos); \r\n\trotate(rotation);\r\n\trect(0, 0, 35, 35);  \r\n\tpopMatrix();\r\n}\r\n```\r\n\r\nNous avons maintenant ce qu’il nous faut, il ne nous reste maintenant plus qu’à écrire notre code autour…  Pour animer notre image, nous allons utiliser une variable pour stocker l’angle auquel seront dessinés nos carrés, à chaque image (donc à chaque répétition de la boucle draw) nous allons augmenter la valeur de cet angle. Une petite astuce pour obtenir un rendu plus « ondulant » sera d’attribuer des valeurs d’angles différentes en fonction de la position du carré dans la grille !\r\n\r\nVous pouvez aussi le voire ici :\r\nhttp://www.openprocessing.org/sketch/60014\r\n\r\net consulter la vidéo d'abe pazos de funprogamming dont ce code est tirée : http://funprogramming.org/35-A-grid-of-rotating-objects-creates-a-wave-of-rectangles.html\r\n\r\n![exemples_pdf/Sketch_1_10.pde](assets/010_grid.png)\r\n\r\n<a name=\"Interactions-Souris-et-clavier\"/>\r\n#Interactions avec la souris et le clavier\r\n\r\nProcessing nous donne accès à des fonctions bien pratiques pour créer de l’interaction avec nos programmes, notament à travers l’utilisation de fonction spécifiques permettant d’intercepter les événements provenant de notre souris ou de notre clavier.\r\n\r\n<a name=\"souris\"/>\r\n##Souris\r\nLes évenements provenant de la souris peuvent être captés de diverses façon. Il est par exemple possible de connaitre la position de la souris à tout moment, de savoir quel bouton est activé etc.\r\n\r\n<a name=\"souris_globales\"/>\r\n###Les variables relatives à la souris\r\n\r\nProcessing met à notre disposition différentes variables globales nous permettant de connaitre l’état de notre souris, ainsi :\r\n**mouseX** et **mouseY** , nous permettent de connaitre les coordonnées de la position de la souris dans notre fenêtre à tout moment.\r\n\r\n**mousePressed** : nous renvoi un booléen : TRUE si la souris est cliquée, FALSE sinon.\r\n**mouseButton** : nous permet de connaitre l’identité du bouton qui a été cliqué\r\n\r\nLe sketch_1_11 met en oeuvre ces variables en imprimant leurs valeurs dans la console.\r\n\r\nIl existe aussi les variables pmouseX et pmouseY qui permette de connaitre la position de la souris à l’image précédente., combinées à mouseX et mouseY, il devient assez facile de calculer la vitesse de déplacement de la souris : \r\n\r\n```java\r\nvoid setup() {\r\n  size(200, 200);\r\n  background(0);\r\n  strokeWeight(4);\r\n  frameRate(15);\r\n  colorMode(HSB, 360, 100, 100);\r\n}\r\nvoid draw() {\r\n  noStroke();\r\n  fill(0, 25);\r\n  rect(0, 0, width, height);\r\n  stroke(random(360), 100, 100);\r\n  line(pmouseX, pmouseY, mouseX, mouseY);\r\n}\r\n```\r\n\r\n![Sketch_1_12.pde](assets/011_mouse.png)\r\n\r\n<a name=\"souris_fonctions\"/>\r\n###Les fonctions relatives à la souris\r\n\r\nIl existe aussi un certain nombre de fonctions permettant d’exectuer un bloc de code en fonction d’un événement souris :\r\n\r\n* mousePressed() : lorsque l’on appuie sur un bouton.\r\n* mouseReleased() : lorsque l’on relâche un bouton.\r\n* mouseClicked() : lorsque l’on appuie puis que l’on relâche un bouton.\r\n* mouseMoved() : lorsque l’on déplace la souris.\r\n* mouseDragged() : lorsque l’on déplace la souris alors qu’un bouton est appuyé.\r\n* mouseWheel() : lorsque l’on active la molette.\r\n\r\nToutes ces fonctions s’utilisent de la même façon : elles sont déclarés comme n'importe quelle fonction, le bloc présent entre les accolades est executé quand la fonction est déclenchée.\r\n\r\n```java\r\nvoid setup() {\r\n  size(200, 200);\r\n}\r\n\r\nvoid draw() {\r\n}\r\n\r\nvoid mousePressed() {\r\n  noStroke();\r\n  fill(random(255), random(255), random(255), random(100, 180)); \r\n  ellipse(mouseX, mouseY, 15, 15);\r\n}\r\n```\r\n![exemples_pdf/Sketch_1_13.pde](assets/012_mouse_pressed.png)\r\n\r\nUn petit point cependant sur la fonction mouseWheel(),avec laquelle on peut obtenir le sens de déplacement de la molette, par le biais d’un MouseEvent.\r\n\r\n```java\r\nfloat hue=180;\r\n\r\nvoid setup() {\r\n  size(200, 200);\r\n  colorMode(HSB,360,100,100);\r\n}\r\n\r\nvoid draw() {\r\n  background(hue,100,100);\r\n}\r\n\r\nvoid mouseWheel(MouseEvent event) {\r\n  float amt = event.getCount();\r\n  hue +=amt;\r\n}\r\n```\r\n\r\n![exemples_pdf/Sketch_1_14.pde](assets/013_mouse_wheel.png)\r\n\r\n<a name=\"map\"/>\r\n###map()\r\n\r\nLa fonction map() peut s’avérer être très utile dans le cadre de divers programmes. Elle permet d’échelonner des valeurs d’un intervalle à un autre. Imaginons par exemple qu’en fonction de la position de la souris nous voulions changer la taille d’un cercle. \r\n\r\nNous voulons que lorsque la souris est tout à gauche de l’écran, notre cercle soit petit (disons un diamètre de 5) et que lorsque nous sommes tout à droite notre cercle soir gros (un diamètre de 100). Nous savons déjà que lorsque notre souris est tout à gauche la variable mouseX aura pour valeur 0, lorsqu’elle est tout à droite sa valeur est de « width » (la variable globale contenant la largeur de notre fenêtre de dessin). La fonction map nous permettra alors de transformer la position de notre souris (comprise entre 0 et width) en une valeur comprise entre 5 et 100.\r\n\r\n```java\r\n\tfloat diam ;\r\n\tdiam = map(mouseX,0,width,5,100) ;\r\n```\r\n\r\n<a name=\"clavier\"/>\r\n##Clavier\r\n\r\nDe la même façon, les évènements claviers peuvent être interceptés. Il existes les variables :\r\n * **key**\r\n * **keyCode**\r\n\r\nqui retournent les valeurs de la dernière touche de clavier enfoncée ; il existe aussi des fonctions similaires à celles de la souris :\r\n * **keyPressed()**\r\n * **keyReleased()**\r\n * **keyTyped()**\r\n\r\n**keyTyped()**  va ignorer l’enfoncement des touches CTRL, ALT etc.\r\n\r\nEn fonction des machines, des systèmes d’exploitation ces fonctions et variables ne renvoient pas systématiquement les même valeurs. Attention donc pour le développement sur plusieurs plateformes.(Pour débugger il est conseillé d’avoir recours à des println pour vérifier les valeurs dans la console). Le chapitre suivant concernant le texte et les polices de caractère vous donnera un exemple d’utilisation de ces fonction.\r\n\r\n<a name=\"Dessiner-du-texte-et-utiliser-des-polices-de-caractère\"/>\r\n#Dessiner du texte, utiliser des polices de caractère\r\n\r\nLe programme suivant va permettre de stocker les lettres tapées sur notre clavier dans une variable de type String et va dessiner ensuite ces lettres de manière aléatoire sur l’écran. La fonction keyPressed() va gérer l’ensemble des interactions avec le clavier.\r\n\r\nPour dessiner du texte nous utilisons à la ligne 22 la fonction :\r\n```java\r\ntext (string, int, int) ;\r\n```\r\n\r\npermettant de dessiner une chaine de caractère en spécifiant les coordonnées auxquelles la dessiner. Le rendu du texte est affecté par la fonction fill() comme n’importe quelle forme géométrique, mais ne réponds pas à la fonction stroke().\r\n\r\nDeux autres fonctions permettent de modifier l’apparence du rendu du texte :\r\n```java\r\ntextSize(float) ;\r\n```\r\n\r\nutilisée à la ligne 20, permet d’en changer la taille, et\r\n```java\r\ntextFont(PFont) ;\r\n```\r\npermet de changer la police à la ligne21. Le type PFont est un objet permettant de charger une police externe chargée dans un fichier « *.vlw ».\r\n\r\nOn utilise donc une variable « font » de type PFont pour charger nos polices à la volée en fonction des touches enfoncées.\r\n\r\nConcernant les interaction clavier, on utilise une technique de « castage » pour forcer le type de donnée que l’on va obtenir de la variable key. A la ligne 24, on s’assure que notre variable k sera bien un caractère avant de l’insérer dans notre chaine de caractères principale, à la ligne 25 on s’assure d’obtenir un entier pour avoir l’identifiant de la touche. Ensuite à l’aide de tests, nous définissons les action à effectuer.\r\n\r\n```java\r\nString buff = \"        \";\r\nPFont font;\r\n\r\nvoid setup() {\r\n  size(400, 300);\r\n  background(255);\r\n  colorMode(HSB);\r\n  smooth();\r\n  font =loadFont(\"Mosaicleaf-48.vlw\");\r\n}\r\n\r\nvoid draw() { \r\n  noStroke();\r\n  fill (255, 35);\r\n  rect (0, 0, width, height);\r\n  char k = buff.charAt(floor(random(buff.length()-1))); \r\n  fill(random(255), 255, 255);\r\n  textSize(random(48, 100));\r\n  textFont(font, 48);\r\n  text(k, random(0, width), random(0, height));\r\n}\r\n\r\nvoid keyPressed() {\r\n\r\n  char k = (char)key;\r\n  int nkey = (int) key;\r\n\r\n  if (nkey == 48) {\r\n    font = loadFont(\"Mosaicleaf-48.vlw\");\r\n  }\r\n  else if (nkey == 49) {\r\n    font =loadFont(\"Bauhaus93-48.vlw\");\r\n  }\r\n  else if (nkey == 50) {\r\n    font =loadFont(\"HarlowSolid-48.vlw\");\r\n  }\r\n  else if (nkey==51) {\r\n    font =loadFont(\"Magneto-Bold-48.vlw\");\r\n  }\r\n  else if (nkey == 51 || nkey ==52 || nkey ==53 ||nkey ==54\r\n    || nkey ==55 ||nkey == 56 || nkey == 57) {\r\n  }\r\n  else if (key == BACKSPACE) {\r\n    buff = \"  \";\r\n  }\r\n  else {\r\n    buff=k+buff;\r\n  }\r\n}\r\n```\r\n\r\n![exemples_pdf/Sketch_1_15.pde](assets/014_fonts.png)\r\n\r\nIl existe un outil permettant de construire des fonts au format .vlw et donc utilizable dans processing à partir des polices installées sur le système. Il suffit de cliquer sur le menu « Tools -> Create Font ».\r\n\r\n<a name=\"Les-Classes-Programmation-Orientée-Objet\"/>\r\n#Les Classes : Programmation Orientée Objet\r\n\r\nLes classes sont un des concepts centraux de JAVA, elles nous permettent de créer des objets ensuite manipulables par du code. Souvent une classe permet d’encapsuler un certain nombre de concepts ensembles d’un façon générique, et permet d’améliorer la lisibilité de notre code.\r\n\r\nCela peut paraître un peu barbare mais c’est en réalité relativement simple : un classe est la description théorique d’un objet. Par exemple dans ce chapitre nous allons créer un classe « Mover », cette classe permettra de créer un objet (représenté graphiquement par un cercle) qui se déplacera dans notre fenêtre de dessin et rebondira contre les bords.\r\n\r\n<a name=\"structre-classe\"/>\r\n##Structure d’une classe\r\n\r\nSa structure ressemble furieusement à la structure d’un programme processing. D’abord nous déclarerons des variables qui pourront être utilisées dans le code de notre classe. Ensuite il nous faudra une fonction pour initialiser ces variables , jusque là nous appelions ça la fonction « setup() », dans un classe cette fonction s’appelle un constructeur. Après cela nous aurons une ribambelle de fonctions qui seont appelées à chaque image calculée, qui nous permettra soit de dessiner quelquechose soit de modéliser un comportement physique, biologique , une interaction avec l’utilisateur etc.\r\n\r\n```java\r\nclass Mover {\r\n\t// déclaration de variables\r\n\t// constructeur\r\n\tMover(){\r\n\t// intialisation des variables\r\n\t}\r\n\r\n\tvoid update(){\r\n\t// faire des calculs\r\n\t}\r\n\r\n\tvoid draw(){\r\n\t// dessiner quelquechose\r\n\t}\r\n}\r\n```\r\n\r\n<a name=\"construction-classe\"/>\r\n##Construction d'une classe simple\r\n\r\n\r\n<a name=\"declaration-variables-classe\"/>\r\n###Déclaration de variables\r\n\r\nPour construire notre classe Mover, nous allons utiliser un nouveau type de variable, le PVector. Cette variable est bien sûr l’équivalent d’un vecteur mathématique, son utilisation nous simplifiera grandement la vie pour l’implémentation du comportement physique que nous souhaitons. (rappelons tout de même qu’un vecteur n’est ni plus ni moins qu’un couple de coordonées).\r\n\r\nMover aura donc besoin pour fonctionner de deux vecteurs : un vecteur définissant la position de notre objet, et un vecteur définissant sa vitesse. Nous n’aurons donc que deux variables à déclarer :\r\n\r\n```java\r\nPVector loc, vel; \r\n```\r\n\r\n<a name=\"constructeur-classe\"/>\r\n###Constructeur : initialisation\r\n\r\nPour initialiser ces variales nous allons utiliser le même type de technique que lorsque nous avions écrit des fonctions. Nous allons nous attacher à pouvoir passer des arguments à notre objet. Cela signifie que lors de la création de l’objet, nous devrons nous même spécifier certaines valeurs, qui seront propre à cet objet crée. La classe elle n’a que faire de ses valeurs, elle ne les manipule que comme des valeurs symboliques. Sans surprise le constructeur resemblera donc à ça :\r\n\r\n```java\r\nMover(PVector loc, PVector vel) {\r\n    this.loc = loc;\r\n    this.vel = vel;\r\n}\r\n\r\n```\r\n\r\nIl est important de bien comprendre ici le fonctionnement du mot clé « this » qui peut créer une confusion. \r\n\r\nDans notre classe nous avons déclarer deux PVector : ‘loc’ et ‘vel’. Nous avons fait de même entre les parenthèse de notre constructeur pour pouvoir passer des valeurs. Rappelez vous de la portée des variables (vue au tout début de ce document). Dans le cadre de notre constructeur nous avons donc deux fois, deux variables qui portent le même nom ; il faut donc impérativement être capable de les différencier. \r\n\r\nLe « this » sert à cela. Lorsque vous êtes dans cette situation le fait d’utiliser « this. » permet de signifier à notre programme que l’on parle de la variable de la classe, celle qui a été déclarée avant notre fonction.  Nous allons donc toujours avoir :\r\n\r\n```java\r\nthis.maVariable = maVariable ;\r\n```\r\nAutrement dit on attribue à la variable qui est utilisée dans notre classe, la valeur que l’on spécifie en argument de notre fonction.\r\n\r\n<a name=\"méthodes-classe\"/>\r\n###Méthodes complémentaires : update() et draw()\r\n\r\nEn physique, il existe un lien entre la position, la vitesse et l’acceleration. Si l’on dérive l’accéleration par rapport au temps on obtient la vitesse, si l’on dérive cette vitesse on obtient la position. Et inversement si on intégre la position par rapport au temps on obtient la vitesse et si on intègre la vitesse on obtient la position (vérifiez si vous ne me croyez pas  !). Pour nous cela signifie que pour calculer la position de notre objet à l’image suivante , il suffit d’ajouter la vitesse à notre position actuelle ! un petit tour rapide sur la page d’aide de PVector nous apprend qu’il existe une méthode « add() » pour ajouter deux objets PVector. La fonction update() de notre classe contiendra donc très certainement cette ligne de code :\r\n\r\n```java\r\nloc.add(vel); \r\n```\r\n\r\nIl ne nous reste plus qu’à dessiner quelquechose … et ça nous savons déjà le faire.\r\n\r\n```java\r\nclass Mover {\r\n\r\n PVector loc, vel;\r\n\r\n Mover(PVector loc, PVector vel) {\r\n   this.loc = loc;\r\n   this.vel = vel;\r\n } \r\n\r\n void update() {  \r\n    loc.add(vel);  \r\n }\r\n\r\n void draw() {\r\n    pushStyle();\r\n    noStroke();\r\n    fill(255, 100);\r\n    ellipse(loc.x, loc.y, 25, 25);\r\n } \r\n}\r\n```\r\n\r\nVoici donc notre classe quasi-complétée.  Il nous reste à utiliser des tests pour savoir si nos objets sortent de l’écran ; si c’est le cas il faut qu’ils rebondissent ! On écrit donc une nouvelle fonction spécifique.\r\n\r\n```java\r\nvoid check_collisions(){\r\n\tif (loc.x < 0 || loc.x> width) { // trop à gauche ou (‘||’) trop à droite\r\n    \tvel.x = -vel.x; // on inverse sa vitesse en abscisse\r\n   \t}\r\n\t// meme schema pour les collision en haut et en bas avec l’ordonnée\r\n\tif (loc.y<0 || loc.y > height) {\r\n    \tvel.y = -vel.y;\r\n\t}\r\n}\r\n```\r\n<a name=\"utilisation-classe\"/>\r\n##Utilisation d'une classe simple\r\n\r\nMaintenant notre classe écrite nous allons pouvoir l’utiliser. Vous trouvez peut-être que pour l’intant c’est beaucoup de code pour pas grand-chose, mais la magie de la programmation objet va commencer à opérer.\r\n\r\nNotre classe écrite nous pouvons maintenant créer des objets que nous pourrons manipuler. Nous pouvons par exemple maintenant déclarer un nouvel objet Mover comme n’importe quel autre type de processing (int, float, string…).1. M1. Mover mov ;over mov ;\r\n\r\n```java\r\nMover mov ;\r\n```\r\n\r\nCette ligne déclarer un nouvel objet, pour l’instant notre objet n’existe cependant toujours pas, nous disons juste à notre ordinateur  que nous allons le créer. Nous allons le créer dans le setup() de notre programme, mais nous avons d’abord besoin de créer deux PVector que nous passerons en argument : un pour la position de notre objet, un pour sa vitesse. Ensuite nous pourrons créer un nouvel objet de type Mover en utilisant la syntaxe :\r\n\r\nmov = new Mover(monVecteur1, mon Vecteur2) ;\r\n\r\nVoici donc le code du setup complet d'un setup initialisant un objet Mover\r\n\r\n```java\r\nvoid setup() {\r\n\r\n  size (800, 600);\r\n\r\n  PVector initLoc = new PVector(width/2, height/2);\r\n  PVector initAcc = new PVector(1.05, -2.25);\r\n  mov = new Mover (initLoc, initAcc);\r\n}\r\n```\r\n\r\nRemarquez, que la façon dont nous initialisons les PVector et notre objet Mover est quasi-identique. C’est normal puisque l’objet PVector est lui-même un classe, qui est déjà codée pour nous.\r\n\r\nNotre objet est donc crée, il ne nous reste plus qu’à la manipuler et à l’afficher. Cette étape se passera donc dans le draw() :\r\n\r\n```java\r\nvoid draw() {\r\n  background(180); // fond noir\r\n  mov.update(); // calculer la position\r\n  mov.draw();  // afficher notre forme\r\n}\r\n```\r\n\r\nLe code assemblé est disponible dans *Sketch_2_01*. \r\n\r\n![exemples_pdf/Sketch_2_01.pde](assets/015_oop1.png)\r\n\r\nA priori cela représente beaucoup d'efforts pour peux d'avantages, mais l'usage conjoint de classes et de tableaux, permet de simplifier la manipulation de milliers d'objets.\r\n\r\n<a name=\"Les-Tableaux\"/>\r\n#Les Tableaux\r\n\r\nLes tableaux sont un type d’objets complexes, ils nous permettent de stocker un grand nombre d’éléments de n’importe quel type float, string …  ou même une classe que nous venons de créer. C’est précisément ce que nous allons faire. Cela nous permettra de traiter un maximum d’objet avec un minimum de lignes de code.\r\n\r\nPour créer un tableau nous devons connaitre le nombre d’éléments que nous allons stocker, il nous faudra donc d’abord définir une variable pour définir la taille de notre tableau. Ensuite un tableau se crée en utilisant des crochets ‘[‘ et ‘]’. Il nous faut d’abord définir le type d’objets que va contenir le tableau, puis ouvrir et fermer des crochets pour signifier que c’est un tableau, donner un nom à cet objet puis l’initialiser à l’aide du mot clé « new ». Pour créer un tableau de 100 objets Move, il suffit donc d’écrire ceci :\r\n\r\n```java\r\nint num = 100 ; \r\nMover[] movs = new Mover[num];\r\n```\r\n\r\nPour créer un tableau de 100 flottants :\r\n```java\r\nFloat[] flottants = new float[100] ;\r\n```\r\n\r\nMaintenant que nous avons crée notre tableau, il nous faut initialiser les éléments qui le compose (dans le cas d’une classe) ou leur attribuer une valeur (dans le cas de flottants) pour cela nous allons utiliser une boucle for pour parcourir l’ensemble de ses  éléments.  Pour accéder à un élément précis, on utilise le nom du tableau et entre crochet l’index de l’élément auquel on veut accéder :\r\n\r\n```java\r\nflottants[5] = 10 ;\r\n```\r\nva attribuer la valeur 10 à l’index 5 de notre tableau de flottants.\r\n\r\nPour initialiser notre tableau d’objets Mover , nous allons parcourir l’ensemble du tableau à l’aide d’une boucle, et à chaque index nous allons stocker un nouvel objet en appelant le constructeur de notre classe.\r\n\r\n```java\r\nvoid setup() {\r\n  size (800, 600);\r\n  for (int i = 0 ; i < num ; i++) {\r\n    PVector initLoc = new PVector(random(5, width-5), random(5, height-5));\r\n    PVector initVel = new PVector(random(-1,1), random(-1,1));\r\n    movs[i] = new Mover (initLoc, initVel);\r\n  }\r\n}\r\n```\r\nEnfin il ne nous reste plus qu’à utiliser nos objets dans le draw(), encore à l’aide d’un boucle for.\r\n\r\n```java\r\nvoid draw() {\r\n\tbackground(180); \r\n\tfor (int i = 0 ; i < num ; i++) {\r\n    \tmovs[i].update();\r\n    \tmovs[i].draw();\r\n\t} \r\n}\r\n```\r\n\r\n![exemples_pdf/Sketch_2_02.pde](assets/016_oop2.png)\r\n\r\nNous avons donc maintenant 1000 objets Mover qui agissent indépendamment les uns des autres, et rebondissent sur les bords de notre fenêtre de dessin. \r\n\r\n<a name=\"Emergence\"/>\r\n#Emergence : Un programme interactif complexe\r\n\r\nEn repartant du programme précédent, nous allons nous attacher à représenter les choses d’un manière différente. Nous verrons qu’en changeant un peu de perspective nous arriverons à des résultats différents et graphiquement plus intéressants.\r\n\r\nL’émergence en terme graphique peut être définie comme l’apparition de structures graphiques complexes et ordonnées à partir d’action simples.\r\n\r\nNous avons donc toujours un programme dessinant un certain nombre de particules qui se déplacent et rebondissent contre les bords de notre fenêtre de dessin. Au lieu de dessiner chaque particule individuellement, nous allons plutôt dessiner un lien entre deux de ces particules uniquement si la distance qui les sépare est inférieure à une certaine valeur.\r\n\r\nCette valeur sera un variable nommée « treshold », elle sera ajusté en fonction de la position de la souris à l’aide de la fonction map() à la ligne 21.Nous n’utilisons plus la fonction draw() de notre classe Mover, elle a donc disparu.\r\n\r\nPour dessiner ce lien nous allons devoir utiliser une double boucle pour parcourir deux fois notre tableau de movers, en faisant attention à gérer le cas où l’on fait référence au même objet :  à la ligne 27, nous vérifions que i est bien différent (« != ») de j.\r\n\r\nNous utilisons la fonction dist() pour calculer la distance entre les coordonnées des deux objets, puis si cette valeur est inférieur à notre treshold, nous dessinons une ligne utilisant ces mêmes coordonées aux lignes 28,29 et 30. Et voilà !\r\n\r\n```java\r\nint num = 1000;\r\nMover[] movs = new Mover[num];\r\n\r\nvoid setup() {\r\n  background(0);\r\n  size (800, 600, P2D);\r\n  for (int i = 0 ; i < num ; i++) {\r\n    PVector initLoc = new PVector(random(5, width-5), random(5, height-5));\r\n    PVector initVel = new PVector(random(-1, 1), random(-1, 1));\r\n    movs[i] = new Mover (initLoc, initVel);\r\n  }\r\n}\r\n\r\n\r\nvoid draw() {\r\n  noStroke();\r\n  fill(0, 50);\r\n  rect(0, 0, width, height);\r\n\r\n  stroke(255);\r\n  float treshold = map(mouseX, 0, width, 0, 50);\r\n\r\n  for (int i = 0 ; i < num ; i++) {\r\n    movs[i].update();\r\n\r\n    for (int j = 0 ; j < num ; j++) {\r\n      if (i!=j) {\r\n        float dist = dist(movs[i].loc.x, movs[i].loc.y, movs[j].loc.x, movs[j].loc.y);\r\n        if (dist < treshold) {\r\n          line(movs[i].loc.x, movs[i].loc.y, movs[j].loc.x, movs[j].loc.y);\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n \r\nclass Mover {\r\n\r\n  PVector loc, vel;\r\n\r\n  Mover(PVector loc, PVector vel) {\r\n    this.loc = loc;\r\n    this.vel = vel;\r\n  } \r\n\r\n  void update() {  \r\n    loc.add(vel);  \r\n    if (loc.x < 0 || loc.x> width) {\r\n      vel.x = -vel.x;\r\n    }\r\n    if (loc.y<0 || loc.y > height) {\r\n      vel.y = -vel.y;\r\n    }\r\n  }\r\n}\r\n```\r\n![exemples_pdf/Sketch_2_03.pde](assets/017_oop3.png)\r\n\r\n\r\n<a name=\"Travailler-avec-les-images\"/>\r\n#Travailler avec les images\r\n\r\nProcessing utilise un classe pour travailler avec les images, pour les manipuler nous avons recours à l’objet « PImage ».\r\n\r\n<a name=\"Charger-image\"/>\r\n#Charger et afficher une image\r\n\r\nPour charger et afficher une image dans Processing, il faut d’abord s’assurer qu’elle soit d’un type accepté par processing à savoir : .gif, .jpg, .tga, ou .png.\r\n\r\nIl faut ensuite s’assurer qu’elle soit visible par le programme sur lequel on travaille. Pour cela il est préférable de sauvegarder le sketch, puis de glissr l’image à ajouter au sketch sur le fenêtre de processing. \r\n\r\nDans le dossier du sketch en question (menu : Sketch -> Show sketch floder ) apparaitra alors un dossier nommé « data », qui contiendra votre image.\r\n\r\nUne fois ces opération effectuées vous pouvez charger votre image comme ceci : \r\n\r\n```java\r\nPImage img;\r\n\r\nvoid setup(){\r\n \r\n  img = loadImage(\"visage.jpg\");\r\n  size(600,400);  \r\n  println(img.width, img.height);\r\n   \r\n}\r\n \r\nvoid draw(){ \r\n   background(0);\r\n   image(img,0,0); \r\n}\r\n\r\nA la ligne 1 on crée un nouvel objet PImage appelé « img », on l’initialise à la ligne 5 en chargeant l’image présente dans le dossier data. En suite à la ligne 13, on affiche cette image, au point de coordonnées (0,0).\r\n\r\nCe code correspond au *Sketch_4_01.pde*.\r\n\r\n![exemples_pdf/Sketch_4_01.pde](assets/018_images.png)\r\n\r\n<a name=\"pixels-image\"/>\r\n#Acccéder aux pixels\r\n\r\nUne fois l’image chargée, il est possible de faire énormément de manipulations, il existe beaucoup d’exemples dans la documentation en ligne de processing a propos des filtres que l’on peut appliquer. Nous allons plutôt nous intéresser à la manipulation de pixels. \r\n\r\nIl existe une fonction appelée « loadPixels() » qui permet de charger automatiquement les couleurs des pixels d’une image dans un tableau qui se nommera pixels[]. \r\n\r\nLe code suivant permet de lire la teinte du pixel d’une image pré-chargée à l’endroit précis du curseur de la souris :\r\n\r\n```java\r\nPImage img ;\r\n\r\nvoid setup(){ \r\n  background(0);\r\n  img = loadImage(\"ville.jpg\");\r\n  size(img.width,img.height,P3D);   \r\n}\r\n  \r\nvoid draw(){\r\n   background(0);\r\n   image(img,0,0);\r\n   \r\n   img.loadPixels();  \r\n   int mousePos = mouseX + mouseY*width;\r\n   println(hue(img.pixels[mousePos]));\r\n   \r\n}\r\n```\r\n\r\nJusqu’à la ligne 14, normalement tout va bien. La ligne 15 va appeler la fonction loadPixels() sur l’image que nous avons chargée, cela aura pour effet de nous permettre d’utiliser le tableau de pixels à la ligne 17 (« img.pixels[] »). Nous utilisons directement la fonction hue pour connaitre la teinte du pixel en question (se référer à l’usage de la fonction hue(myColor) dans la documentation en ligne). \r\nIl faut cependant bien noter qu’à la ligne 16 nous convertissons les coordonnées de la souris en index linéaire dans un tableau.\r\n\r\nEn effet, pixels[] est un tableau, à titre chaque valeur est stockée à un index précis, mais cet index est à une seule dimension, alors que les coordonnée de la souris sont en 2D.\r\n\r\nCette pipette à couleur es disponible dans les exemples : *Sketch_4_02*.\r\n\r\n\r\n<a name=\"pixels-3d\"/>\r\n#Faire « sortir » les pixels en 3D\r\n\r\nA partir de maintenant il devient très facilement possible d’effectuer tout un tas d’effets artistiques animés, en se basant sur les données des pixels. Dans le programme suivant nous allons nous attacher à déplacer les pixels en fonction de leur luminosité (et de la position de la souris, pour accentuer ou diminuer l’effet).\r\n\r\nAfin d’avoir un programme plus rapide, nous allons avoir un setup() un peu plus long que d’habitude. En effet pour ne pas avoir à appeler la fonction loadPixels() en permanence, nous allons le faire une seule fois dans le setup de notre programme. Cela nous permettra de remplir des tableaux pour mieux organiser nos données et pouvoir ainsi les dessiner plus simplement. Comme précédemment nous allons parcourir chaque pixel de l’image à l’aide d’une double boucle for, et nous allons stocker dans des tableaux de même dimension, les coorodonnées en x dans le tableau xC[], les coordonnées en y dans le tableau yC[] et la couleur de chaque pixel dans le tableau pColor[].\r\n\r\n```java\r\nPImage img ;\r\n\r\nint [] xC;\r\nint [] yC;\r\nint [] pColor;\r\n \r\nvoid setup() {\r\n  size(500, 400, P3D);\r\n  background(0);\r\n  img = loadImage(\"image_200x100.jpg\");\r\n  img.loadPixels();\r\n \r\n  xC = new int[img.pixels.length];\r\n  yC = new int[img.pixels.length];\r\n  pColor = new int[img.pixels.length];\r\n\r\n  for (int i =0 ; i < img.width ; i++) {\r\n    for (int j = 0 ; j < img.height; j++) {\r\n      int loc = i + j*img.width;\r\n      xC[loc] =i;\r\n      yC[loc] =j;\r\n      pColor[loc] = img.pixels[loc];\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nNotez bien l’apparition du mode P3D dans l’instruction de taille de la fenêtre. Maintenant que nous avons ces informations, nous allons parcourir nos tableaux à chaque image et pour chaque valeur de l’index : créer un rectangle de la même couleur que le pixel d’origine et d’un taille de 1px X 1px, bref nous allons recréer l’image avec nos propres objets. La seule différence étant que nous allons ajouter une composante de translation en z, permettant de faire ressortir les pixels.\r\n\r\nPour obtenir l’effet souhaité, nous allons cependant le faire en deux fois. L’objectif est d’avoir l’image intacte quand la souris est à gauche de l’écran et « éclatée » quand la souris est à droite. A la ligne04 ci-dessous, nous allons donc définir une variable valant 0 quand la souris est à gauche et 60 quand la souris est à droite, ce que nous avions déjà fait précédemment.\r\n\r\nEnsuite nous créons une boucle pour parcourir nos tableaux, nous stockons la luminosité de chaque pixel dans une variable à la ligne 07, puis nous nous apprêtons à dessiner avec des translations (usage du pushMatrix() …). La ligne 11 contient le positionnement de chaque forme : on décale de 150 pixels vers la droite et de 150 pixels vers le bas pour mieux centrer, puis on utilise les coordonnées stockées, en dernier paramètre on multiplie nos deux variable (position de la souris et luminosité) pour faire en sorte que les pixels les plus lumineux ressortent le plus.\r\n\r\n```java\r\nvoid draw() {\r\n  background(0);\r\n  float push_z = map(mouseX, 0, width, 0, 60);\r\n  \r\n  for (int i = 0 ; i < xC.length ; i++) {\r\n    float br = brightness(pColor[i]);\r\n    pushMatrix();\r\n    noStroke();\r\n    fill(pColor[i]);\r\n    translate(150+ xC[i]+5, 150+yC[i]+5, push_z*br/20);\r\n    rect(0, 0, 1, 1);\r\n    popMatrix();\r\n  }\r\n}\r\n```\r\n\r\n![exemples_pdf/Sketch_4_03.pde](assets/019_pixels.png)\r\n\r\n\r\n<a name=\"Les-Librairies\"/>\r\n#Les Librairies\r\n\r\nUn des grands avantages de Processing est sa vibrante communauté d’utilisateurs, qui écrit des tutoriels, qui documentent et partagent leurs travaux. Les développeurs de Processing ont voulu permettre aux utilisateurs développer leurs propres librairies et de les intégrer dans Processing.\r\n\r\nIl existe un grand nombre de librairies pour faire beaucoup de choses différentes : \r\nhttp://processing.org/reference/libraries/\r\n\r\nIl en existe pour tout un tas d’applications : pour animer, pour contrôler de la vidéo, pour exporter ou importer des formats de données particuliers, pour faire de la 3d, de la typographie ou encore pour faire parler son ordinateur…\r\n\r\nNous allons nous intéresser principalement à deux librairies, une permettant de créer des boutons et des sliders pour contrôler nos sketch processing : controlP5. L’autre permettant de faire communiquer deux programmes entre eux. Ces deux librairies ont été codées par Andreas Schlegel (http://www.sojamo.de/code/), un grand merci à lui !\r\n\r\n\r\n<a name=\"installation\"/>\r\n##Installation d'une librairie\r\n\r\nDepuis la version 2.0 de processing, il existe un outil permettant d’installer facilement des librairies, c’est le « library manager » accessible depuis le menu « sketch -> Import library -> Add library ». \r\n\r\nCet utilitaire permet de naviguer parmi les librairie disponibles de les installer ou de les supprimer. \r\n\r\nSi toute fois l’utilitaire ne fonctionnait pas bien, il existe un dossier spécifique dans notre sketchbook appelé « libraries » qui stocke toutes nos librairies installées. Pour rappel l’emplacement du sketchbook est modifiable dans « file -> Preferences ». Pour installer une librairie, il suffit de télécharger la librairie, de dézipper l’archive et de placer le dossier dans votre dossier « libraries »\r\n\r\nGénéralement une librairie est composée d’un dossier principal contenant quatre sous-dossier :\r\n* /examples/\r\n* /library/\r\n* /reference/\r\n* /src/\r\n\r\nDans le dossier /library/ vous devez normalement trouver un fichier *.jar portant le même nom que votre dossier racine. Si c’est bien le cas votre librairie sera alors reconnue et utilisable.\r\n\r\nGénéralement lorsque vous installez une librairie elle est fournie avec un certains nombres d’exemples censé expliquer son fonctionnement. On y accède via le menu File->Examples, il faut ensuite naviguer jusqu’au menu déroulant intitulé « Contributed Libraries », puis trouver le dossier correspondant à la librairie installée.\r\n\r\n<a name=\"cp5\"/>\r\n##ControlP5 pour la création de GUI (exemples de niveau intermédiaire)\r\n\r\nControlP5 est une librairie permettant des créer des GUI (« General User Interface »), c’est-à-dire des boutons et des glissières permettant de contrôler certains paramètres de notre programme.\r\n\r\nEn naviguant jusqu’à l’aide fournie avec la librairie, vous constaterez qu’elle est bien réelle et extensive (peut-être même un peu trop). \r\n\r\nLe dossier /controllers/, présente l’ensemble des éléments de GUI implémentés : allant du bouton, à la liste en accordéon, en passant par les doubles sliders (ControlP5range) et autres surface de type pad XY (ControlP5slider2D).\r\n\r\nLes dossiers /extra/ et/use/, introduisent  quelques notions plus avancées, et notamment l’utilisation d’une fenêtre externe pour y placer les éléments de GUI. C’est l’exemple auquel nous allons nous intéresser.\r\n\r\n```java\r\n/**\r\n * ControlP5 Controlframe\r\n * by Andreas Schlegel, 2012\r\n * www.sojamo.de/libraries/controlp5\r\n *\r\n*/\r\nimport java.awt.Frame;\r\nimport java.awt.BorderLayout;\r\nimport controlP5.*;\r\n \r\nprivate ControlP5 cp5;\r\n \r\nControlFrame cf;\r\n\r\nint def;\r\n\r\nvoid setup() {\r\n  size(400, 400);\r\n  cp5 = new ControlP5(this);\r\n\r\n  cf = addControlFrame(\"extra\", 200, 200);\r\n}\r\n \r\nvoid draw() {\r\n background(def);\r\n}\r\n \r\nControlFrame addControlFrame(String theName, int theWidth, int theHeight) {\r\n Frame f = new Frame(theName);\r\n ControlFrame p = new ControlFrame(this, theWidth, theHeight);\r\n f.add(p);\r\n p.init();\r\n f.setTitle(theName);\r\n f.setSize(p.w, p.h);\r\n f.setLocation(100, 100);\r\n f.setResizable(false);\r\n f.setVisible(true);\r\n return p;\r\n}\r\n\r\n```\r\n\r\nDans cette première partie, on commence par importer les librairies nécessaires. On utilise ControlP5, déclarée en ligne 9, mais aussi deux classes provenant directement de Java.awt (AWT = Abstract Window Toolkit), ce qui nous permettra de créer une seconde fenêtre pour notre programme. Nous auront aussi besoin d’une classe que nous adapterons suivant nos besoins, elle est donnée ci-dessous.\r\nAprès avoir appelé nos librairies, nous créons une instance de ControlP5 qui s’appelera « cp5 » à la ligne 11, qui sera initialisée à la ligne 19 dans le setup().\r\n\r\nEnsuite nous créons un nouveau ControlFrame appelé « cf » à la ligne 13. ControlFrame signifie fenêtre de contrôle et sera donc notre seconde fenêtre dans laquelle nous placerons notre interface. Notez bien que lors de son initialisation à la ligne 21, nous appelons une fonction spécifique qui commence à la ligne 28 et s’achève à la ligne 39. Cette fonction va appeler les fonctions java que l’on a importé pour créer une fenêtre portant le nom que l’on aura spécifié en premier argument, et les dimensions en deuxième et troisième arguments. Cette fonction n’a pas besoin d’être modifiée et peut rester la même à chaque utilisation.\r\n\r\nDans cette fonction à la ligne 30, on appelle le constructeur de la classe ControlFrame décrite ci-dessous. Cela permet créer  la fenêtre de manière et de créer un lien entre les deux fenêtre, cela sort du cadre de cette introduction (« this » et « Object parent » y sont pour beaucoup). Il faut s’attarder sur la méthode setup() de cette nouvelle classe(lignes 47 à 53), pour comprendre comment ajouter des contrôleurs dans notre nouvelle fenêtre.\r\n\r\n```java\r\npublic class ControlFrame extends PApplet {\r\n\r\n  int w, h;\r\n  int abc = 100;\r\n  ControlP5 cp5;\r\n  Object parent;\r\n\r\n  public void setup() {\r\n    size(w, h);\r\n    frameRate(25);\r\n    cp5 = new ControlP5(this);\r\n    cp5.addSlider(\"abc\").setRange(0, 255).setPosition(10, 10);\r\n    cp5.addSlider(\"def\").plugTo(parent, \"def\").setRange(0, 255).setPosition(10, 30);\r\n  }\r\n\r\n  public void draw() {\r\n    background(abc);\r\n  }\r\n\r\n  private ControlFrame() {\r\n  }\r\n\r\n  public ControlFrame(Object theParent, int theWidth, int theHeight) {\r\n    parent = theParent;\r\n    w = theWidth;\r\n    h = theHeight;\r\n  }\r\n\r\n  public ControlP5 control() {\r\n    return cp5;\r\n  }\r\n}\r\n```\r\n\r\nEn premier lieu notre classe fait appel à une nouvelle instance de controlP5 rattachée à cette nouvelle fenêtre (ligne 50). A la ligne 51, on crée un slider appelé « abc », qui va sortir des valeurs comprises entre 0 et 255, et qui sera situé à la position (10,10) dans la nouvelle fenêtre. De part son nom, les valeurs du slider « abc », seront directement stockées dans la variable du même nom.\r\n\r\nA la ligne 52 on crée un second slider, cette fois appelé « def », qui va sortir le même type de valeurs, à la différence que ces données seront envoyées à notre fenêtre parente, et stockées dans notre variable de type entier « def ».\r\n\r\nD’un façon générale, il est plus clair d’utiliser systématiquement fonction « .plugTo(this,myVar) » pour associer la valeur d’un gui à une variable. Dans notre exemple, on utilise « parent », pour spécifier qu’il s’agit d’une autre fenêtre que l’on a préalablement définit, mais l’utilisation de « this » permet de le faire aussi lorsque contrôles et dessins se passent dans la même fenêtre.\r\n\r\n![cp5 exemple](assets/018_cp5.png)\r\n\r\nUne fois la librairie installée vous pourrez trouver un exemple ici :\r\nFile->Examples->ContributerLibrairies-> ControlP5->Extra->ControlP5frame.pde\r\n\r\nControlP5 est une librairie très aboutie avec beaucoup de fonctionnalités, mais sa mise en œuvre peut-être parfois un peu lourde. S’il s’agit de faire des tests, le mode « Tweak » peut  s’avérer être une bonne alternative.\r\n\r\n<a name=\"oscp5\"/>\r\n##OSCP5 pour la communication avec d’autres programmes\r\n\r\nOSCP5 est un support pour processing de la fameuse librairie de communication entre différents paradigmes de programmation. OSC est présent dans quasiment tous les langages c’est donc un classique à connaitre et à utiliser sans modération.\r\n\r\nLes exemples sketch_3_01_OSC_Receive.pde et sketch_3_01_OSC_Send.pde sont donc à utiliser conjointement. Le premier programme recevra des informations du second, et changera sa couleur de fond en fonction de la valeur reçue. Le second programme, enverra une valeur aléatoire lorsque l’on clique sur sa fenêtre.\r\n\r\nPour effectuer cela, il important de pouvoir spécifier une adresse ip pour pouvoir envoyer un message a un endroit précis et un numéro de port.\r\n\r\n```java\r\n//Receiver\r\nimport oscP5.*;\r\nimport netP5.*;\r\n\r\nOscP5 oscP5;\r\n\r\nfloat receivedValue;\r\n \r\nvoid setup() {\r\n  size(400, 400);\r\n  frameRate(25);\r\n\r\n  receivedValue =0;\r\n\r\n  oscP5 = new OscP5(this, 1234);\r\n}\r\n \r\nvoid draw() {\r\n  background(receivedValue);\r\n}\r\n \r\nvoid oscEvent(OscMessage theOscMessage) {\r\n   if (theOscMessage.checkAddrPattern(\"/test\")==true) {\r\n     float firstValue = theOscMessage.get(0).floatValue();  \r\n     String secondValue = theOscMessage.get(1).stringValue();\r\n     receivedValue = firstValue;\r\n   }\r\n  }\r\n}\r\n```\r\n\r\nLes lignes 2 et 3 permettent d’importer les objets nécessaires. La ligne 5 crée une instance d’OSCP5 La ligne 15, située dans le setup est primordiale pour le bon fonctionnement de notre programme, le second argument fourni (ici « 1234 » )  est nôtre numéro de port, cette ligne signifie donc que nous écouterons toutes les informations entrantes sur cette machine (« this ») transitant par le port « 1234 ».  Lorsqu’une telle information sera reçue, elle activera la fonction présente de la ligne 22 à la ligne 28.\r\n\r\nUn message OSC est avant tout un préfixe « /test » ici, permettant de trier les messages arrivant puis un tableau remplit de variable de différents types, il est alors toujours plus pratique de savoir exactement ce que l’on va recevoir. Ici, comme vous pourrez le voire ci-après notre message est , d’un préfixe « /test » puis est composé : d’un float aléatoire, et d’un string constant. Pour accéder à l’élément « n » du message on utilise « theOscMessage.get(n) », puis on utilise l’accesseur approprié au type de valeur que l’on reçoit (« .floatValue() »  pour un float).\r\n\r\nLa ligne 23 reçoit donc une valeur flottante, la ligne 25 stocke cette valeur dans une variable qui va servir à spécifier la couleur de fond de notre fenêtre.\r\n\r\n```java\r\n// Sender\r\nimport oscP5.*;\r\nimport netP5.*;\r\n\r\nOscP5 oscP5;\r\nNetAddress myRemoteLocation;\r\n\r\nvoid setup() {\r\n  size(400, 400);\r\n  frameRate(25);\r\n\r\n  oscP5 = new OscP5(this, 12000);\r\n  myRemoteLocation = new NetAddress(\"127.0.0.1\", 1234);\r\n}\r\n \r\nvoid draw() {\r\n   background(0);\r\n}\r\n \r\nvoid mousePressed() {\r\n\r\n  OscMessage myMessage = new OscMessage(\"/test\");\r\n  myMessage.add(random(255));\r\n  myMessage.add(\"hello!\");\r\n \r\n  oscP5.send(myMessage, myRemoteLocation);\r\n}\r\n```\r\n\r\nJusqu’à la ligne 6, rien de nouveau sous le soleil.\r\n\r\nA la ligne 6, apparait cependant un nouvel objet propre à OSCP5 : un objet de type NetAdress, c’est en fait un couple composé d’une adresse ip et d’un numéro de port, comme vous pouvez le constater à la ligne 13.\r\n\r\nLe reste du programme tient dans la fonction mousePressed() (lignes 21 à 29).  A la ligne 23 on crée un nouveau message avec un préfixe spécifique. A la ligne 25 on lui ajoute une première donnée (un nombre aléatoire), puis une seconde à la ligne 26. La ligne 28, envoit notre message à l’adresse que nous avons spécifié dans le setup.\r\n\r\nN’oubliez pas de faire attention aux adresses ip et au numéros de ports lorsque vus utilisez OSCP5, n’hésitez pas non plus à faire des print pour être bien sûrs de recevoir vos messages !\r\n\r\nLe Chapitre suivant vous donnera un exemple permettant de de commander Processing à l’aide d’une analyse audio faite dans Pure Data.\r\n\r\n<a name=\"audio-réactif\"/>\r\n#3D et audio-réactif avec Pure-Data\r\n\r\nPour compléter le petit projet initié dans le chapitre sur les images, nous allons ajouter une partie audio-réactive, le temps pour Pure-Data et OSC de se rappeler à nos bons souvenirs…\r\n\r\nPour faire simple nous n’allons plus utiliser la souris pour contrôler la quantité de déplacement de nos pixels, mais plutôt le niveau sonore ambiant dans la pièce dans laquelle nous travaillons. Nous allons faire l’analyse audio dans Pure-Data puis envoyer les données via OSC à Processing.\r\n\r\nEn ce qui concerne le code Processing, nous prenons le programme précédent, auquel nous apportons quelques modifications, notamment pour ajouter la librairie OSCP5 et ajuster la réception des messages (un seul float avec le préfixe « /env »). Il faut aussi pense à la ligne 40 à changer la valeur de push_z en fonction des données que l’on reçoit.\r\n\r\n```java\r\nimport oscP5.*;\r\nimport netP5.*;\r\n\r\nOscP5 oscP5;\r\n\r\nfloat r_env = 0 ;\r\n\r\nPImage img ;\r\n\r\nint [] xC;\r\nint [] yC;\r\nint [] pColor;\r\n \r\nvoid setup() {\r\n   size(500, 400, P3D);\r\n   background(0);\r\n   img = loadImage(\"image_200x100.jpg\");\r\n   img.loadPixels();\r\n \r\n    oscP5 = new OscP5(this, 8600);\r\n   \r\n   xC = new int[img.pixels.length];\r\n   yC = new int[img.pixels.length];\r\n   pColor = new int[img.pixels.length];\r\n \r\n   for (int i =0 ; i < img.width ; i++) {\r\n     for (int j = 0 ; j < img.height; j++) {\r\n       int loc = i + j*img.width;\r\n       xC[loc] =i;\r\n       yC[loc] =j;\r\n       pColor[loc] = img.pixels[loc];\r\n     }\r\n   }\r\n} \r\n \r\nvoid draw() {\r\n  background(0);\r\n\r\n  float push_z = map(r_env, 45, 90, 0, 60);\r\n  \r\n  for (int i = 0 ; i < xC.length ; i++) {\r\n    float br = brightness(pColor[i]);\r\n     pushMatrix();\r\n     noStroke();\r\n     fill(pColor[i]);\r\n     translate(150+ xC[i]+5, 150+yC[i]+5, push_z*br/20);\r\n     rect(0, 0, 1, 1);\r\n     popMatrix();\r\n  }\r\n}\r\n \r\n \r\nvoid oscEvent(OscMessage theOscMessage) {\r\n   if (theOscMessage.checkAddrPattern(\"/env\")==true) {\r\n     float firstValue = theOscMessage.get(0).floatValue();  \r\n     \r\n     r_env = firstValue;\r\n   }\r\n}\r\n```\r\n\r\nSe référer au *Sketch_4_04*.\r\n![exemples_pdf/Sketch_4_04.pde](assets/021_audio-réactif.png)\r\n\r\n\r\nLe patch Pure-Data est quand à lui très simple : il utilise la librairie « mrpeach » qui permet l’utilisation de boites spécifiques à l’envoi de messages OSC.\r\n\r\n![exemples_pdf/pd-analysis](assets/022_audio-réactif-pd.png)\r\n\r\net voilà !\r\n\r\n<a name=\"Trucs-et-astuces\"/>\r\n#Trucs et astuces\r\n\r\nInspiré de la rubrique de Amnon sur son wordpress :\r\nhttp://amnonp5.wordpress.com/2012/01/28/25-life-saving-tips-for-processing/\r\n\r\n##IDE\r\n\r\n* Ctrl + T : permet de formater le texte de notre code en le ré-indentant en fonction des accolades.\r\n* File -> Preferences : emplacement du sketchbook\r\n* File -> Examples : exemples de programmes classés selon différentes catégories, la documentation des librairies est aussi disponible sous cet onglet.\t\r\n\r\n##Programmation abréviation des opérations\r\n```java\r\ni = i+1 ;\r\n```\r\n est équivalent à\r\n```java\r\ni+=1 ;\r\n```\r\n\r\n##Graphisme\r\n\r\n###Un blur très simple\r\nAu lieu d’effacer le fond à chaque image en utilisant \r\n```java\r\nbackground (maCouleur) ;\r\n```\r\nIl est très simple de créer un effet de « blur » en utilisant de la transparence.\r\n```java\r\nfill(0,20) ;\r\nnoStroke();\r\nrect(0,0,width,height) ;\r\n```\r\n\r\n###Color Selector\r\nUtilisez l’outil Color Selector pour spécifier plus facilement vos couleurs dans les different modes.\r\nTools -> Color Selector.\r\n\r\n###In/Out\r\n####Sauvegarder une image\r\n\r\nPour sauvegarder un image on peut utiliser la fonction saveFrame(), on peut la coupler avec une interaction clavier, ainsi qu’une condition pour que la sauvegarde s’effectue lorsqu’on appuie sur la touche S. Le must est de composer une chaîne de caractère pour que chaque fichier ait un nom unique.\r\n```java\r\n// function d’interception des évenements clavier\r\nvoid keyPressed() {\r\n // condition pour identifier si la touche est un “s”\r\n if (key == 's' || key == 'S') {\r\n  /* composition d’une string comportant le nom du sketch puis des informations de temps à l’aide de functions de processing pour récupérer des événements temporels*/\r\n  String name = \"monSketch-\"+year()+\"-\"+month()+\"-\"+day()+\"-\"+hour()+\"h\"+minute()+\"m\"+second()+\"s.png\"\r\n  saveFrame(name);\r\n }\r\n}\r\n```\r\n####Redimensionner une image\r\n\r\nIl suffit de changer la taille de la fenêtre du programme pour sauvegarder une image au nouvelles dimensions.\r\n```java\r\nPImage img ;\r\n\r\nvoid setup(){\r\n  size(200,100,P3D);\r\n  background(0);\r\n  img = loadImage(\"ville.jpg\");\r\n  img.resize(width,height);  \r\n}\r\n\r\n \r\nvoid draw(){  \r\n  background(0);\r\n  image(img,0,0);\r\n  saveFrame(\"image_\"+width+\"x\"+height+\".jpg\");\r\n  noLoop();\r\n}\r\n```\r\n\r\n<a name=\"Ressources\"/>\r\n#Ressoures\r\n\r\nSite officiel : http://processing.org/\r\n\r\nLa référence de l’API processing : http://processing.org/reference/\r\n\r\nLe Wiki( parfois la référence n’est pas complète) : http://wiki.processing.org/w/Main_Page\r\n\r\nLes tutoriaux officiels : http://processing.org/tutorials/\r\n\r\nPlus à propos de processing :  http://en.wikipedia.org/wiki/Processing_(programming_language)\r\n\r\nInitiation (français) : http://fr.flossmanuals.net/processing/\r\n\r\nRessources diverses : http://codelab.fr/39\r\n\r\nForum dédié à Processing (français) : http://codelab.fr/processing\r\n\r\nForum officiel de Processing (anglais) : http://forum.processing.org/\r\n\r\nTutoriel (français) : http://www.ecole-art-aix.fr/rubrique81.html\r\n\r\nD’autres tutoriels en français : http://tutoprocessing.com/tutos/\r\n\r\nVidéos de fun programming : http://funprogramming.org/\r\n\r\nVidéos de Daniel Shiffmann : \r\n\r\nComputer programming for total beginner : https://vimeo.com/channels/introcompmedia\r\n\r\nNature of Code : https://vimeo.com/channels/natureofcode\r\n# ",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}